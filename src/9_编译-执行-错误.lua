---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by luowei.
--- DateTime: 2019/8/15 20:47
--- 编译、执行与错误
---

------------------------------------ 编译 ----------------------------------
-- Lua是一种解释性语言，衡量解释性语言的主要特征在于它是否有能力执行动态生成的代码。
-- Lua中有dofile和loadfile两个函数可用于执行动态生成的代码
-- dofile用于从文件中加载并运行Lua代码块
-- loadfile用于从文件中加载Lua代码块，并对代码进行编译，将编译的结果作为一个函数返回。它不会运行加载的Lua代码，但是可以通过调用loadfile编译结果返回的函数来运行。
-- 如果需要多次运行同一个文件中的Lua代码，使用loadfile只需要编译一次，开销会小很多
-- loadstring与loadfile的区别是：该方法是从一个字符串中加载并编译Lua代码，它也会返回一个函数
print("loadstring")
i = 0
f = loadstring("i = i + 1")
f()
print("", "i = " .. i)

-- loadstring总是在全局上下文中编译它的字符串，如下所示：
i = 32
local i = 0
f = loadstring("i = i + 1; print('', 'i from loadstring: ' .. i)")      -- 执行结果将是 i = 33（引用了全局变量i）
g = function() i = i + 1; print('', 'i from function: ' .. i) end       -- 执行结果将是 i = 1 （引用了局部变量i）
f();    g();

-- Lua将所有程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变长实参。例如：loadstring("a = 1")返回的结果等价于 function(...) a = 1 end
f = loadstring("p1,p2 = ...; print('', 'p1 = ' .. tostring(p1) .. ', p2 = ' .. tostring(p2))")
f('a', 'b', 'c')            -- 前面两个参数'a'和'b'将赋值给loadstring中的p1和p2

------------------------------------ 错误 ----------------------------------
print("错误")
-- Lua作为一种扩展语言，通常嵌入在应用程序中，因此，在发生错误时它不能简单地崩溃或退出，相反，Lua应该结束当前程序块并返回应用程序。
-- Lua通过调用error函数可以显示的引发一个错误
-- if not n then error("invalid input") end     -- 这段代码将引发一个错误，程序将终止执行
-- Lua中有一个专门的函数 assert(<condition>, <msg>)，其等价于 if not <condition> then error(<msg>) end
-- assert函数检查第一个参数是否为true，若为true，则简单的返回该参数；否则，就引发一个错误，assert的第二个参数是一个可选的值（不一定是字符串），它将出现在错误信息中。
-- assert(n, "invalid input")                   -- 这段代码将引发一个错误，程序将终止执行

-- pcall函数用于捕获函数执行过程中发生的错误，pcall(f, arg1, ... argn)，其中，第一个参数为需要执行的函数名称，后面的参数将作为实参传递给函数f
function anyError(type)             -- 当传入1时，引发错误，错误信息为一个对象；为2时，错误信息为一个字符串。所以为2的时候，Lua才会附加错误发生的位置信息
    if type == 1 then error({code = 9999, message = "error happend"})
    else error("error happend")
    end
end
r, err = pcall(anyError, 2)
if r then
    -- foo()执行没有发生错误，走这里
    print("", "pcall", "ok", "r = " .. tostring(r))
else
    -- foo()执行发生错误了，执行这里
    if type(err) == 'table' then
        print("", "pcall", "err", "code = " .. err.code .. ", message = " .. err.message)
    else
        print("", "pcall", "err", err)
    end
end

------------------------------------ 错误消息与追溯 ----------------------------------
print("\n错误消息与追溯")
-- 虽然可以使用任何类型的值作为错误消息，但是仅当错误消息是一个字符串时，Lua才会附加一些关于错误消发生位置的信息

-- anyError(2)                      -- 此处调用会抛出错误

-- 使用pcall调用函数时，如果函数发生错误，pcall会销毁掉部分调用栈的内容，Lua提供了xpcall函数，该函数可以接收一个额外的参数：错误处理函数，Lua会在调用栈展开前调用错误处理函数
-- 可以使用debug.traceback作为错误处理函数，用于构建完整的错误栈信息
-- 使用xpall + debug.traceback的方式，既可以捕获到完整的错误堆栈，又不会在错误发生时导致程序中断运行
re, err = xpcall(anyError, debug.traceback, 2)
print("", "xpcall ------ start\n", err, "\n", "xpcall ------- end")

re, err = pcall(anyError, 2)
print("\n", "pcall ------ start\n", err, "\n", "pcall ------- end")

-- debug.traceback函数也可以在正常的代码行调用，将返回当前执行的堆栈信息
print("\n", "debug.traceback(): ", debug.traceback())

-- 自定义错误接收函数
function errRecv(...)
    for i, v in ipairs({...}) do
        print("", "i = " .. tostring(i) .. ", v = " .. tostring(v))
    end
end
xpcall(anyError, errRecv, 2)
